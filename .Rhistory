# Extract tokens, POS tags, and dependency relations
tokens <- annotated %>% select(token_id, token, xpos, dep_rel, head_token_id)
# Identify clauses based on finite verbs and dependency relations
clauses <- list()
clause_id <- 1
current_clause <- list(tokens = c(), type = NULL, boundary = NULL)
# Heuristic: Clauses often have finite verbs (VERB with tense) or subordinators
verbs <- tokens %>% filter(xpos == "VERB" & !is.na(dep_rel))
subordinators <- tokens %>% filter(xpos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
# Start with the root verb (main clause)
root_verb <- tokens %>% filter(dep_rel == "root")
if (nrow(root_verb) > 0) {
clause_tokens <- tokens %>% filter(token_id >= min(tokens$token_id) & token_id <= max(tokens$token_id))
boundary <- paste(clause_tokens$token, collapse = " ")
clauses[[clause_id]] <- list(
type = "Main Clause",
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
# Identify subordinate clauses (based on subordinators or dependent verbs)
for (i in 1:nrow(subordinators)) {
sub_token <- subordinators[i, ]
sub_token_id <- sub_token$token_id
sub_token_text <- sub_token$token
# Find dependent tokens (subtree of the subordinator)
dependent_tokens <- tokens %>% filter(head_token_id == sub_token_id | token_id >= sub_token_id)
if (nrow(dependent_tokens) > 0) {
boundary <- paste(dependent_tokens$token, collapse = " ")
# Determine clause type
clause_type <- case_when(
sub_token_text %in% c("that", "what", "whether") ~ "Noun Clause",
sub_token_text %in% c("who", "which", "that") & sub_token$dep_rel %in% c("nmod", "acl") ~ "Adjective (Relative) Clause",
sub_token$xpos %in% c("SCONJ", "CCONJ") | sub_token_text == "where" ~ "Adverbial Clause",
TRUE ~ "Unknown"
)
clauses[[clause_id]] <- list(
type = clause_type,
boundary = boundary,
tokens = dependent_tokens
)
clause_id <- clause_id + 1
}
}
# Store results for this sentence
results[[sentence]] <- clauses
}
return(results)
}
# Run analysis
clause_results <- analyze_clauses(sentences)
knitr::opts_chunk$set(echo = TRUE)
sentences <- c(
"On Friday, it was revealed that former Milwaukee Sheriff David Clarke, who was being considered for Homeland Security Secretary in Donald Trump’s administration, has an email scandal of his own.",
"In January, there was a brief run-in on a plane between Clarke and fellow passenger Dan Black, who he later had detained by the police for no reason whatsoever, except that maybe his feelings were hurt.",
"On Christmas day, Donald Trump announced that he would be back to work the following day, but he is golfing for the fourth day in a row."
)
# Function to annotate sentences and extract clause information
analyze_clauses <- function(sentences) {
# Initialize result storage
results <- list()
for (sentence in sentences) {
# Annotate sentence with UDPipe
annotated <- udpipe_annotate(ud_model, x = sentence) %>% as.data.frame()
# Extract tokens, POS tags, and dependency relations
tokens <- annotated %>% select(token_id, token, upos, dep_rel, head_token_id)
# Identify clauses based on finite verbs and dependency relations
clauses <- list()
clause_id <- 1
current_clause <- list(tokens = c(), type = NULL, boundary = NULL)
# Heuristic: Clauses often have finite verbs (VERB with tense) or subordinators
verbs <- tokens %>% filter(upos == "VERB" & !is.na(dep_rel))
subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
# Start with the root verb (main clause)
root_verb <- tokens %>% filter(dep_rel == "root")
if (nrow(root_verb) > 0) {
clause_tokens <- tokens %>% filter(token_id >= min(tokens$token_id) & token_id <= max(tokens$token_id))
boundary <- paste(clause_tokens$token, collapse = " ")
clauses[[clause_id]] <- list(
type = "Main Clause",
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
# Identify subordinate clauses (based on subordinators or dependent verbs)
for (i in 1:nrow(subordinators)) {
sub_token <- subordinators[i, ]
sub_token_id <- sub_token$token_id
sub_token_text <- sub_token$token
# Find dependent tokens (subtree of the subordinator)
dependent_tokens <- tokens %>% filter(head_token_id == sub_token_id | token_id >= sub_token_id)
if (nrow(dependent_tokens) > 0) {
boundary <- paste(dependent_tokens$token, collapse = " ")
# Determine clause type
clause_type <- case_when(
sub_token_text %in% c("that", "what", "whether") ~ "Noun Clause",
sub_token_text %in% c("who", "which", "that") & sub_token$dep_rel %in% c("nmod", "acl") ~ "Adjective (Relative) Clause",
sub_token$upos %in% c("SCONJ", "CCONJ") | sub_token_text == "where" ~ "Adverbial Clause",
TRUE ~ "Unknown"
)
clauses[[clause_id]] <- list(
type = clause_type,
boundary = boundary,
tokens = dependent_tokens
)
clause_id <- clause_id + 1
}
}
# Store results for this sentence
results[[sentence]] <- clauses
}
return(results)
}
# Run analysis
clause_results <- analyze_clauses(sentences)
knitr::opts_chunk$set(echo = TRUE)
# Checking that NLP resources are available
file.edit("~/.Rprofile")
knitr::opts_chunk$set(echo = TRUE)
sentences <- c(
"On Friday, it was revealed that former Milwaukee Sheriff David Clarke, who was being considered for Homeland Security Secretary in Donald Trump’s administration, has an email scandal of his own.",
"In January, there was a brief run-in on a plane between Clarke and fellow passenger Dan Black, who he later had detained by the police for no reason whatsoever, except that maybe his feelings were hurt.",
"On Christmas day, Donald Trump announced that he would be back to work the following day, but he is golfing for the fourth day in a row."
)
ud_model <- udpipe_download_model(language = "english")
ud_model <- udpipe_load_model(ud_model$file_model)
# Function to annotate sentences and extract clause information
analyze_clauses <- function(sentences) {
# Initialize result storage
results <- list()
for (sentence in sentences) {
# Annotate sentence with UDPipe
annotated <- udpipe_annotate(ud_model, x = sentence) %>% as.data.frame()
# Extract tokens, POS tags, and dependency relations
tokens <- annotated %>% select(token_id, token, upos, dep_rel, head_token_id)
# Identify clauses based on finite verbs and dependency relations
clauses <- list()
clause_id <- 1
current_clause <- list(tokens = c(), type = NULL, boundary = NULL)
# Heuristic: Clauses often have finite verbs (VERB with tense) or subordinators
verbs <- tokens %>% filter(upos == "VERB" & !is.na(dep_rel))
subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
# Start with the root verb (main clause)
root_verb <- tokens %>% filter(dep_rel == "root")
if (nrow(root_verb) > 0) {
clause_tokens <- tokens %>% filter(token_id >= min(tokens$token_id) & token_id <= max(tokens$token_id))
boundary <- paste(clause_tokens$token, collapse = " ")
clauses[[clause_id]] <- list(
type = "Main Clause",
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
# Identify subordinate clauses (based on subordinators or dependent verbs)
for (i in 1:nrow(subordinators)) {
sub_token <- subordinators[i, ]
sub_token_id <- sub_token$token_id
sub_token_text <- sub_token$token
# Find dependent tokens (subtree of the subordinator)
dependent_tokens <- tokens %>% filter(head_token_id == sub_token_id | token_id >= sub_token_id)
if (nrow(dependent_tokens) > 0) {
boundary <- paste(dependent_tokens$token, collapse = " ")
# Determine clause type
clause_type <- case_when(
sub_token_text %in% c("that", "what", "whether") ~ "Noun Clause",
sub_token_text %in% c("who", "which", "that") & sub_token$dep_rel %in% c("nmod", "acl") ~ "Adjective (Relative) Clause",
sub_token$upos %in% c("SCONJ", "CCONJ") | sub_token_text == "where" ~ "Adverbial Clause",
TRUE ~ "Unknown"
)
clauses[[clause_id]] <- list(
type = clause_type,
boundary = boundary,
tokens = dependent_tokens
)
clause_id <- clause_id + 1
}
}
# Store results for this sentence
results[[sentence]] <- clauses
}
return(results)
}
# Run analysis
clause_results <- analyze_clauses(sentences)
knitr::opts_chunk$set(echo = TRUE)
# sentences <- c(
#   "On Friday, it was revealed that former Milwaukee Sheriff David Clarke, who was being considered for Homeland Security Secretary in Donald Trump’s administration, has an email scandal of his own.",
#   "In January, there was a brief run-in on a plane between Clarke and fellow passenger Dan Black, who he later had detained by the police for no reason whatsoever, except that maybe his feelings were hurt.",
#   "On Christmas day, Donald Trump announced that he would be back to work the following day, but he is golfing for the fourth day in a row."
# )
#
# ud_model <- udpipe_download_model(language = "english")
# ud_model <- udpipe_load_model(ud_model_info$file_model)
# Download and load UDPipe model
ud_model_info <- udpipe_download_model(language = "english")
ud_model <- udpipe_load_model(ud_model_info$file_model)
#' Analyze clauses in a set of sentences using UDPipe
#' @param sentences A character vector of sentences to analyze
#' @return A list of clause information (type, boundary, tokens) for each sentence
#' @details Identifies main and subordinate clauses based on dependency parsing
analyze_clauses <- function(sentences) {
if (length(sentences) == 0) stop("No sentences provided.")
# Initialize result storage
results <- list()
# Batch annotate sentences
annotated <- udpipe_annotate(ud_model, x = sentences, doc_id = 1:length(sentences)) %>% as.data.frame()
for (sentence in sentences) {
# Filter annotations for current sentence
doc_id <- which(sentences == sentence)
tokens <- annotated %>% filter(doc_id == !!doc_id) %>%
select(token_id, token, upos, dep_rel, head_token_id)
# Initialize clauses
clauses <- list()
clause_id <- 1
# Identify main clause (root verb)
root_verb <- tokens %>% filter(dep_rel == "root")
if (nrow(root_verb) > 0) {
clause_tokens <- tokens %>% filter(token_id %in% get_subtree_ids(tokens, root_verb$token_id))
boundary <- paste(clause_tokens$token, collapse = " ")
clauses[[clause_id]] <- list(
type = "Main Clause",
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
# Identify subordinate clauses
subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
for (i in 1:nrow(subordinators)) {
sub_token <- subordinators[i, ]
clause_tokens <- tokens %>% filter(token_id %in% get_subtree_ids(tokens, sub_token$token_id))
if (nrow(clause_tokens) > 0) {
boundary <- paste(clause_tokens$token, collapse = " ")
clause_type <- case_when(
sub_token$dep_rel == "mark" & sub_token$token %in% c("that", "whether") ~ "Noun Clause",
sub_token$dep_rel == "acl:relcl" ~ "Adjective (Relative) Clause",
sub_token$dep_rel %in% c("advcl", "mark") & sub_token$upos == "SCONJ" ~ "Adverbial Clause",
TRUE ~ "Unknown"
)
clauses[[clause_id]] <- list(
type = clause_type,
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
}
results[[sentence]] <- clauses
}
return(results)
}
# Helper function to get subtree token IDs
get_subtree_ids <- function(tokens, start_id) {
ids <- c(start_id)
children <- tokens %>% filter(head_token_id %in% ids)
while (nrow(children) > 0) {
ids <- c(ids, children$token_id)
children <- tokens %>% filter(head_token_id %in% children$token_id)
}
return(ids)
}
# # Function to annotate sentences and extract clause information
# analyze_clauses <- function(sentences) {
#   # Initialize result storage
#   results <- list()
#
#   for (sentence in sentences) {
#     # Annotate sentence with UDPipe
#     annotated <- udpipe_annotate(ud_model, x = sentence) %>% as.data.frame()
#
#     # Extract tokens, POS tags, and dependency relations
#     tokens <- annotated %>% select(token_id, token, upos, dep_rel, head_token_id)
#
#     # Identify clauses based on finite verbs and dependency relations
#     clauses <- list()
#     clause_id <- 1
#     current_clause <- list(tokens = c(), type = NULL, boundary = NULL)
#
#     # Heuristic: Clauses often have finite verbs (VERB with tense) or subordinators
#     verbs <- tokens %>% filter(upos == "VERB" & !is.na(dep_rel))
#     subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
#
#     # Start with the root verb (main clause)
#     root_verb <- tokens %>% filter(dep_rel == "root")
#     if (nrow(root_verb) > 0) {
#       clause_tokens <- tokens %>% filter(token_id >= min(tokens$token_id) & token_id <= max(tokens$token_id))
#       boundary <- paste(clause_tokens$token, collapse = " ")
#       clauses[[clause_id]] <- list(
#         type = "Main Clause",
#         boundary = boundary,
#         tokens = clause_tokens
#       )
#       clause_id <- clause_id + 1
#     }
#
#     # Identify subordinate clauses (based on subordinators or dependent verbs)
#     for (i in 1:nrow(subordinators)) {
#       sub_token <- subordinators[i, ]
#       sub_token_id <- sub_token$token_id
#       sub_token_text <- sub_token$token
#
#       # Find dependent tokens (subtree of the subordinator)
#       dependent_tokens <- tokens %>% filter(head_token_id == sub_token_id | token_id >= sub_token_id)
#       if (nrow(dependent_tokens) > 0) {
#         boundary <- paste(dependent_tokens$token, collapse = " ")
#
#         # Determine clause type
#         clause_type <- case_when(
#           sub_token_text %in% c("that", "what", "whether") ~ "Noun Clause",
#           sub_token_text %in% c("who", "which", "that") & sub_token$dep_rel %in% c("nmod", "acl") ~ "Adjective (Relative) Clause",
#           sub_token$upos %in% c("SCONJ", "CCONJ") | sub_token_text == "where" ~ "Adverbial Clause",
#           TRUE ~ "Unknown"
#         )
#
#         clauses[[clause_id]] <- list(
#           type = clause_type,
#           boundary = boundary,
#           tokens = dependent_tokens
#         )
#         clause_id <- clause_id + 1
#       }
#     }
#
#     # Store results for this sentence
#     results[[sentence]] <- clauses
#   }
#
#   return(results)
# }
# Run analysis
clause_results <- analyze_clauses(sentences)
knitr::opts_chunk$set(echo = TRUE)
sentences <- c(
"On Friday, it was revealed that former Milwaukee Sheriff David Clarke, who was being considered for Homeland Security Secretary in Donald Trump’s administration, has an email scandal of his own.",
"In January, there was a brief run-in on a plane between Clarke and fellow passenger Dan Black, who he later had detained by the police for no reason whatsoever, except that maybe his feelings were hurt.",
"On Christmas day, Donald Trump announced that he would be back to work the following day, but he is golfing for the fourth day in a row."
)
#
# ud_model <- udpipe_download_model(language = "english")
# ud_model <- udpipe_load_model(ud_model_info$file_model)
# Download and load UDPipe model
ud_model_info <- udpipe_download_model(language = "english")
ud_model <- udpipe_load_model(ud_model_info$file_model)
#' Analyze clauses in a set of sentences using UDPipe
#' @param sentences A character vector of sentences to analyze
#' @return A list of clause information (type, boundary, tokens) for each sentence
#' @details Identifies main and subordinate clauses based on dependency parsing
analyze_clauses <- function(sentences) {
if (length(sentences) == 0) stop("No sentences provided.")
# Initialize result storage
results <- list()
# Batch annotate sentences
annotated <- udpipe_annotate(ud_model, x = sentences, doc_id = 1:length(sentences)) %>% as.data.frame()
for (sentence in sentences) {
# Filter annotations for current sentence
doc_id <- which(sentences == sentence)
tokens <- annotated %>% filter(doc_id == !!doc_id) %>%
select(token_id, token, upos, dep_rel, head_token_id)
# Initialize clauses
clauses <- list()
clause_id <- 1
# Identify main clause (root verb)
root_verb <- tokens %>% filter(dep_rel == "root")
if (nrow(root_verb) > 0) {
clause_tokens <- tokens %>% filter(token_id %in% get_subtree_ids(tokens, root_verb$token_id))
boundary <- paste(clause_tokens$token, collapse = " ")
clauses[[clause_id]] <- list(
type = "Main Clause",
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
# Identify subordinate clauses
subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
for (i in 1:nrow(subordinators)) {
sub_token <- subordinators[i, ]
clause_tokens <- tokens %>% filter(token_id %in% get_subtree_ids(tokens, sub_token$token_id))
if (nrow(clause_tokens) > 0) {
boundary <- paste(clause_tokens$token, collapse = " ")
clause_type <- case_when(
sub_token$dep_rel == "mark" & sub_token$token %in% c("that", "whether") ~ "Noun Clause",
sub_token$dep_rel == "acl:relcl" ~ "Adjective (Relative) Clause",
sub_token$dep_rel %in% c("advcl", "mark") & sub_token$upos == "SCONJ" ~ "Adverbial Clause",
TRUE ~ "Unknown"
)
clauses[[clause_id]] <- list(
type = clause_type,
boundary = boundary,
tokens = clause_tokens
)
clause_id <- clause_id + 1
}
}
results[[sentence]] <- clauses
}
return(results)
}
# Helper function to get subtree token IDs
get_subtree_ids <- function(tokens, start_id) {
ids <- c(start_id)
children <- tokens %>% filter(head_token_id %in% ids)
while (nrow(children) > 0) {
ids <- c(ids, children$token_id)
children <- tokens %>% filter(head_token_id %in% children$token_id)
}
return(ids)
}
# # Function to annotate sentences and extract clause information
# analyze_clauses <- function(sentences) {
#   # Initialize result storage
#   results <- list()
#
#   for (sentence in sentences) {
#     # Annotate sentence with UDPipe
#     annotated <- udpipe_annotate(ud_model, x = sentence) %>% as.data.frame()
#
#     # Extract tokens, POS tags, and dependency relations
#     tokens <- annotated %>% select(token_id, token, upos, dep_rel, head_token_id)
#
#     # Identify clauses based on finite verbs and dependency relations
#     clauses <- list()
#     clause_id <- 1
#     current_clause <- list(tokens = c(), type = NULL, boundary = NULL)
#
#     # Heuristic: Clauses often have finite verbs (VERB with tense) or subordinators
#     verbs <- tokens %>% filter(upos == "VERB" & !is.na(dep_rel))
#     subordinators <- tokens %>% filter(upos %in% c("SCONJ", "CCONJ") | token %in% c("that", "who", "which", "where"))
#
#     # Start with the root verb (main clause)
#     root_verb <- tokens %>% filter(dep_rel == "root")
#     if (nrow(root_verb) > 0) {
#       clause_tokens <- tokens %>% filter(token_id >= min(tokens$token_id) & token_id <= max(tokens$token_id))
#       boundary <- paste(clause_tokens$token, collapse = " ")
#       clauses[[clause_id]] <- list(
#         type = "Main Clause",
#         boundary = boundary,
#         tokens = clause_tokens
#       )
#       clause_id <- clause_id + 1
#     }
#
#     # Identify subordinate clauses (based on subordinators or dependent verbs)
#     for (i in 1:nrow(subordinators)) {
#       sub_token <- subordinators[i, ]
#       sub_token_id <- sub_token$token_id
#       sub_token_text <- sub_token$token
#
#       # Find dependent tokens (subtree of the subordinator)
#       dependent_tokens <- tokens %>% filter(head_token_id == sub_token_id | token_id >= sub_token_id)
#       if (nrow(dependent_tokens) > 0) {
#         boundary <- paste(dependent_tokens$token, collapse = " ")
#
#         # Determine clause type
#         clause_type <- case_when(
#           sub_token_text %in% c("that", "what", "whether") ~ "Noun Clause",
#           sub_token_text %in% c("who", "which", "that") & sub_token$dep_rel %in% c("nmod", "acl") ~ "Adjective (Relative) Clause",
#           sub_token$upos %in% c("SCONJ", "CCONJ") | sub_token_text == "where" ~ "Adverbial Clause",
#           TRUE ~ "Unknown"
#         )
#
#         clauses[[clause_id]] <- list(
#           type = clause_type,
#           boundary = boundary,
#           tokens = dependent_tokens
#         )
#         clause_id <- clause_id + 1
#       }
#     }
#
#     # Store results for this sentence
#     results[[sentence]] <- clauses
#   }
#
#   return(results)
# }
# Run analysis
clause_results <- analyze_clauses(sentences)
#
#
annotated <- udpipe_annotate(ud_model, x = sentences, doc_id = 1:length(sentences)) %>% as.data.frame()
#
# # Print column names
colnames(annotated)
#
#
annotated <- udpipe_annotate(ud_model, x = sentences, doc_id = 1:length(sentences)) %>% as.data.frame()
#
# # Print column names
colnames(annotated)
# View(annotated)
tokens <- annotated %>% select(token_id, token, upos, dep_rel, head_token_id)
print(tokens)
# Run analysis
clause_results <- analyze_clauses(sentences)
# Print results in a structured format
for (sentence in names(clause_results)) {
cat("Sentence:", sentence, "\n")
for (clause in clause_results[[sentence]]) {
cat("  Clause Type:", clause$type, "\n")
cat("  Boundary:", clause$boundary, "\n")
cat("  Tokens:\n")
print(clause$tokens)
cat("\n")
}
}
# Run analysis
clause_results <- analyze_clauses(sentences)
knitr::opts_chunk$set(echo = TRUE)
